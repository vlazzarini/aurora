.TH "Aurora" 3 "Sun May 29 2022" "Version 0.1" "Aurora" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Aurora
.SH SYNOPSIS
.br
.PP
.SS "Classes"

.in +1c
.ti -1c
.RI "class \fBBinOp\fP"
.br
.ti -1c
.RI "class \fBBlOsc\fP"
.br
.ti -1c
.RI "class \fBBuff\fP"
.br
.ti -1c
.RI "class \fBCeps\fP"
.br
.ti -1c
.RI "class \fBConv\fP"
.br
.ti -1c
.RI "struct \fBdata_chunk\fP"
.br
.ti -1c
.RI "class \fBDeinterleave\fP"
.br
.ti -1c
.RI "class \fBDel\fP"
.br
.ti -1c
.RI "class \fBEnv\fP"
.br
.ti -1c
.RI "class \fBEq\fP"
.br
.ti -1c
.RI "class \fBFFT\fP"
.br
.ti -1c
.RI "class \fBFil\fP"
.br
.ti -1c
.RI "struct \fBfmt_chunk\fP"
.br
.ti -1c
.RI "class \fBFourPole\fP"
.br
.ti -1c
.RI "class \fBFunc\fP"
.br
.ti -1c
.RI "class \fBIR\fP"
.br
.ti -1c
.RI "class \fBMix\fP"
.br
.ti -1c
.RI "class \fBOnePole\fP"
.br
.ti -1c
.RI "class \fBOsc\fP"
.br
.ti -1c
.RI "class \fBQuad\fP"
.br
.ti -1c
.RI "struct \fBriff_chunk\fP"
.br
.ti -1c
.RI "class \fBSndBase\fP"
.br
.ti -1c
.RI "class \fBSpecBase\fP"
.br
.ti -1c
.RI "class \fBspecdata\fP"
.br
.ti -1c
.RI "class \fBSpecPitch\fP"
.br
.ti -1c
.RI "class \fBSpecPlay\fP"
.br
.ti -1c
.RI "class \fBSpecShift\fP"
.br
.ti -1c
.RI "class \fBSpecStream\fP"
.br
.ti -1c
.RI "class \fBSpecSynth\fP"
.br
.ti -1c
.RI "class \fBSpecTable\fP"
.br
.ti -1c
.RI "class \fBTableSet\fP"
.br
.ti -1c
.RI "class \fBTwoPole\fP"
.br
.ti -1c
.RI "class \fBWave\fP"
.br
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum { \fBSAW\fP = 0, \fBSQUARE\fP, \fBTRIANGLE\fP, \fBPULSE\fP }"
.br
.ti -1c
.RI "enum : int32_t { \fBLP\fP = -1, \fBHP\fP, \fBBP\fP }"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "template<typename S > S \fBfixed_delay\fP (S nop, std::size_t wp, const std::vector< S > &d, std::vector< S > *nop1)"
.br
.ti -1c
.RI "template<typename S > S \fBvdelay\fP (S rp, std::size_t wp, const std::vector< S > &del, std::vector< S > *nop)"
.br
.ti -1c
.RI "template<typename S > S \fBvdelayi\fP (S rp, std::size_t wp, const std::vector< S > &del, std::vector< S > *nop)"
.br
.ti -1c
.RI "template<typename S > S \fBvdelayc\fP (S rp, std::size_t wp, const std::vector< S > &del, std::vector< S > *nop)"
.br
.ti -1c
.RI "template<typename S > S \fBlp_delay\fP (S nop, std::size_t wp, const std::vector< S > &d, std::vector< S > *mem)"
.br
.ti -1c
.RI "template<typename S > S \fBfir\fP (S nop, std::size_t wp, const std::vector< S > &del, std::vector< S > *ir)"
.br
.ti -1c
.RI "template<typename S > S \fBads\fP (S a, S d, S s, double t, S e, S ts)"
.br
.ti -1c
.RI "template<typename S > std::function< S(double, S, S)> \fBenv_gen\fP (const std::vector< S > &pts)"
.br
.ti -1c
.RI "template<typename S > std::function< S(double, S, S)> \fBads_gen\fP (const S &a, const S &d, const S &s)"
.br
.ti -1c
.RI "static uint32_t \fBnp2\fP (uint32_t n)"
.br
.ti -1c
.RI "template<typename S > S \fBreson\fP (S in, double *c, double *d)"
.br
.ti -1c
.RI "template<typename S > void \fBreson_cfs\fP (S f, S bw, S fs, double *c)"
.br
.ti -1c
.RI "template<typename S > void \fBreson_cfs1\fP (S f, S bw, S fs, double *c)"
.br
.ti -1c
.RI "template<typename S > void \fBreson_cfs2\fP (S f, S bw, S fs, double *c)"
.br
.ti -1c
.RI "template<typename S > S \fBdfI\fP (S in, double *c, double *d)"
.br
.ti -1c
.RI "template<typename S > S \fBdfII\fP (S in, double *c, double *d)"
.br
.ti -1c
.RI "template<typename S > void \fBlp_cfs\fP (S f, S bw, S fs, double *c)"
.br
.ti -1c
.RI "template<typename S > void \fBhp_cfs\fP (S f, S bw, S fs, double *c)"
.br
.ti -1c
.RI "template<typename S > void \fBbp_cfs\fP (S f, S bw, S fs, double *c)"
.br
.ti -1c
.RI "template<typename S > void \fBbr_cfs\fP (S f, S bw, S fs, double *c)"
.br
.ti -1c
.RI "template<typename S > S \fBsinn\fP (S ph)"
.br
.ti -1c
.RI "template<typename S > S \fBcosn\fP (S ph)"
.br
.ti -1c
.RI "template<typename S > S \fBlookup\fP (double ph, const std::vector< S > *t)"
.br
.ti -1c
.RI "template<typename S > S \fBlookupi\fP (double ph, const std::vector< S > *t)"
.br
.ti -1c
.RI "template<typename S > S \fBlookupc\fP (double ph, const std::vector< S > *t)"
.br
.ti -1c
.RI "template<typename S > S \fBsin\fP (double ph, const std::vector< S > *t=0)"
.br
.ti -1c
.RI "template<typename S > S \fBcos\fP (double ph, const std::vector< S > *t=0)"
.br
.ti -1c
.RI "template<typename S > S \fBphase\fP (double ph, const std::vector< S > *t=0)"
.br
.ti -1c
.RI "template<typename S > S \fBlinear_interp\fP (double pos, const std::vector< S > &t)"
.br
.ti -1c
.RI "template<typename S > S \fBcubic_interp\fP (double pos, const std::vector< S > &t)"
.br
.ti -1c
.RI "template<typename S > S \fBlinear_interp_lim\fP (double pos, const std::vector< S > &t)"
.br
.ti -1c
.RI "template<typename S > S \fBcubic_interp_lim\fP (double pos, const std::vector< S > &t)"
.br
.ti -1c
.RI "template<typename S > S \fBunwrap\fP (S ph)"
.br
.ti -1c
.RI "template<typename S > S \fBid\fP (S s, S dr)"
.br
.ti -1c
.RI "static char \fBle_test\fP ()"
.br
.ti -1c
.RI "static char * \fBbyteswap\fP (void *pp, int32_t N)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "const double \fBdef_base\fP = 16\&."
.br
.ti -1c
.RI "const std::size_t \fBdef_psize\fP = 2048"
.br
.ti -1c
.RI "const bool \fBola\fP = 1"
.br
.ti -1c
.RI "const bool \fBols\fP = 0"
.br
.ti -1c
.RI "const bool \fBpacked\fP = true"
.br
.ti -1c
.RI "static bool \fBforward\fP = true"
.br
.ti -1c
.RI "static bool \fBinverse\fP = false"
.br
.ti -1c
.RI "const int \fBdef_ftlen\fP = 16384"
.br
.ti -1c
.RI "const double \fBap1\fP []"
.br
.ti -1c
.RI "const double \fBap2\fP []"
.br
.ti -1c
.RI "const int \fBdef_vsize\fP = 64"
.br
.ti -1c
.RI "const double \fBdef_sr\fP = 44100\&."
.br
.ti -1c
.RI "const double \fBtwopi\fP = 2 * \fBM_PI\fP"
.br
.ti -1c
.RI "const std::size_t \fBdef_fftsize\fP = 1024"
.br
.ti -1c
.RI "const std::size_t \fBdef_hsize\fP = 256"
.br
.ti -1c
.RI "const char \fBRIFF_ID\fP [4] = {'R','I','F','F'}"
.br
.ti -1c
.RI "const char \fBWAVE_ID\fP [4] = {'W','A','V','E'}"
.br
.ti -1c
.RI "const char \fBFMT_ID\fP [4] = {'f','m','t',' '}"
.br
.ti -1c
.RI "const char \fBDATA_ID\fP [4] = {'d','a','t','a'}"
.br
.in -1c
.SH "Enumeration Type Documentation"
.PP 
.SS "anonymous enum"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fISAW \fP\fP
.TP
\fB\fISQUARE \fP\fP
.TP
\fB\fITRIANGLE \fP\fP
.TP
\fB\fIPULSE \fP\fP
.SS "anonymous enum : int32_t"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fILP \fP\fP
.TP
\fB\fIHP \fP\fP
.TP
\fB\fIBP \fP\fP
.SH "Function Documentation"
.PP 
.SS "template<typename S > S Aurora::ads (S a, S d, S s, double t, S e, S ts)\fC [inline]\fP"
ADS function for \fBEnv\fP 
.br
S: sample type 
.br
a: attack 
.br
d: decay 
.br
s: sustain 
.br
t: current time 
.br
e: prev sample 
.br
ts: fs reciprocal 
.br
returns an ADS sample 
.SS "template<typename S > std::function< S(double, S, S)> Aurora::ads_gen (const S & a, const S & d, const S & s)"
ADS function generator for \fBEnv\fP 
.br
S: sample type 
.br
a: attack 
.br
d: decay 
.br
s: sustain 
.br
returns an ADS envelope function 
.SS "template<typename S > void Aurora::bp_cfs (S f, S bw, S fs, double * c)\fC [inline]\fP"
Second-order bandpass filter coeffs 
.SS "template<typename S > void Aurora::br_cfs (S f, S bw, S fs, double * c)\fC [inline]\fP"
Second-order notch filter coeffs 
.SS "static char * Aurora::byteswap (void * pp, int32_t N)\fC [inline]\fP, \fC [static]\fP"

.SS "template<typename S > S Aurora::cos (double ph, const std::vector< S > * t = \fC0\fP)\fC [inline]\fP"
Cosine function for \fBOsc\fP 
.br
S: sample type 
.br
ph: normalised phase 
.br
returns the cosine of ph*2*$M_PI 
.SS "template<typename S > S Aurora::cosn (S ph)\fC [inline]\fP"
Cosine function for \fBOsc\fP 
.br
S: sample type 
.br
ph: normalised phase 
.br
returns the cosine of ph*2*$M_PI 
.SS "template<typename S > S Aurora::cubic_interp (double pos, const std::vector< S > & t)\fC [inline]\fP"
cubic interpolation circular table lookup 
.br
S: sample type 
.br
pos: reading position (no bounds check) 
.br
t: table 
.SS "template<typename S > S Aurora::cubic_interp_lim (double pos, const std::vector< S > & t)\fC [inline]\fP"
cubic interpolation limiting table lookup 
.br
S: sample type 
.br
pos: reading position (no bounds check) 
.br
t: table 
.SS "template<typename S > S Aurora::dfI (S in, double * c, double * d)\fC [inline]\fP"
DF-I second-order section 
.SS "template<typename S > S Aurora::dfII (S in, double * c, double * d)\fC [inline]\fP"
DF-II second-order section 
.SS "template<typename S > std::function< S(double, S, S)> Aurora::env_gen (const std::vector< S > & pts)"
Breakpoint function generator for \fBEnv\fP 
.br
S: sample type 
.br
pts: breakpoints {t0,val0,t1,val1,\&.\&.\&.} 
.br
returns an envelope function 
.SS "template<typename S > S Aurora::fir (S nop, std::size_t wp, const std::vector< S > & del, std::vector< S > * ir)\fC [inline]\fP"
FIR/convolution function for \fBDel\fP 
.br
nop: no-op 
.br
wp: write position 
.br
del: delay line 
.br
ir: impulse response 
.br
returns a convolution sample 
.SS "template<typename S > S Aurora::fixed_delay (S nop, std::size_t wp, const std::vector< S > & d, std::vector< S > * nop1)\fC [inline]\fP"
Fixed delay function for \fBDel\fP 
.br
S: sample type 
.br
nop: no op 
.br
wp: reading position (no bounds check) 
.br
d: delay line 
.br
no1p: no op 
.br
returns a sample from the delay line 
.SS "template<typename S > void Aurora::hp_cfs (S f, S bw, S fs, double * c)\fC [inline]\fP"
Second-order hipass filter coeffs 
.SS "template<typename S > S Aurora::id (S s, S dr)\fC [inline]\fP"

.SS "static char Aurora::le_test ()\fC [inline]\fP, \fC [static]\fP"

.SS "template<typename S > S Aurora::linear_interp (double pos, const std::vector< S > & t)\fC [inline]\fP"
linear interpolation circular table lookup 
.br
S: sample type 
.br
pos: reading position (no bounds check) 
.br
t: table 
.SS "template<typename S > S Aurora::linear_interp_lim (double pos, const std::vector< S > & t)\fC [inline]\fP"
linear interpolation limiting table lookup 
.br
S: sample type 
.br
pos: reading position 
.br
t: table 
.SS "template<typename S > S Aurora::lookup (double ph, const std::vector< S > * t)\fC [inline]\fP"
Truncating table lookup for \fBOsc\fP 
.br
S: sample type 
.br
ph: phase 
.br
t: function table 
.br
returns a sample 
.SS "template<typename S > S Aurora::lookupc (double ph, const std::vector< S > * t)\fC [inline]\fP"
Cubic interp table lookup function for \fBOsc\fP 
.br
S: sample type 
.br
ph: phase \\mn t: function table 
.br
returns an interpolated sample 
.SS "template<typename S > S Aurora::lookupi (double ph, const std::vector< S > * t)\fC [inline]\fP"
Linear interp table lookup function for \fBOsc\fP 
.br
S: sample type 
.br
ph: phase \\mn t: function table 
.br
returns an interpolated sample 
.SS "template<typename S > void Aurora::lp_cfs (S f, S bw, S fs, double * c)\fC [inline]\fP"
Second-order lowpass filter coeffs 
.SS "template<typename S > S Aurora::lp_delay (S nop, std::size_t wp, const std::vector< S > & d, std::vector< S > * mem)\fC [inline]\fP"
Lowpass-filtered fixed delay function for \fBDel\fP 
.br
 nop: no-op 
.br
 wp: write position 
.br
 del: delay line 
.br
 mem: a vector of size 2 with the lp filter state (pos 0) and coeff (pos 1) 
.br
 returns a convolution sample 
.SS "static uint32_t Aurora::np2 (uint32_t n)\fC [inline]\fP, \fC [static]\fP"

.SS "template<typename S > S Aurora::phase (double ph, const std::vector< S > * t = \fC0\fP)\fC [inline]\fP"
Phase function for \fBOsc\fP 
.br
S: sample type 
.br
ph: normalised phase 
.br
returns ph 
.SS "template<typename S > S Aurora::reson (S in, double * c, double * d)\fC [inline]\fP"
resonator function for \fBFil\fP 
.SS "template<typename S > void Aurora::reson_cfs (S f, S bw, S fs, double * c)\fC [inline]\fP"
resonator coefficients function for \fBFil\fP no scaling 
.SS "template<typename S > void Aurora::reson_cfs1 (S f, S bw, S fs, double * c)\fC [inline]\fP"
resonator coefficients function for \fBFil\fP scaling type 1 
.SS "template<typename S > void Aurora::reson_cfs2 (S f, S bw, S fs, double * c)\fC [inline]\fP"
resonator coefficients function for \fBFil\fP scaling type 2 
.SS "template<typename S > S Aurora::sin (double ph, const std::vector< S > * t = \fC0\fP)\fC [inline]\fP"
Sine function for \fBOsc\fP 
.br
S: sample type 
.br
ph: normalised phase 
.br
returns the sine of ph*2*$M_PI 
.SS "template<typename S > S Aurora::sinn (S ph)\fC [inline]\fP"
Sine function for \fBOsc\fP 
.br
S: sample type 
.br
ph: normalised phase 
.br
returns the sine of ph*2*$M_PI 
.SS "template<typename S > S Aurora::unwrap (S ph)"

.SS "template<typename S > S Aurora::vdelay (S rp, std::size_t wp, const std::vector< S > & del, std::vector< S > * nop)\fC [inline]\fP"
Truncating delay function for \fBDel\fP 
.br
S: sample type 
.br
rp: reading position 
.br
wp: write position 
.br
d: delay line 
.br
nop: no op 
.br
returns a sample from the delay line floor(rp) samples behind wp 
.SS "template<typename S > S Aurora::vdelayc (S rp, std::size_t wp, const std::vector< S > & del, std::vector< S > * nop)\fC [inline]\fP"
CubicInterpolation delay function for \fBDel\fP 
.br
S: sample type 
.br
rp: reading position 
.br
wp: write position 
.br
del: delay line 
.br
nop: no op 
.br
returns a sample from the delay line rp samples behind wp, 
.br
cubic interpolated 
.SS "template<typename S > S Aurora::vdelayi (S rp, std::size_t wp, const std::vector< S > & del, std::vector< S > * nop)\fC [inline]\fP"
Interpolation delay function for \fBDel\fP 
.br
S: sample type 
.br
rp: reading position 
.br
wp: write position 
.br
d: delay line 
.br
nop: no op 
.br
returns a sample from the delay line rp samples behind wp, 
.br
linearly interpolated 
.SH "Variable Documentation"
.PP 
.SS "const double Aurora::ap1[]"
\fBInitial value:\fP
.PP
.nf
= {
    59\&.017959590337846,
    262\&.34340692699607,
    1052\&.8560831644886,
    4223\&.577583838366,
    17190\&.389734991037,
    130538\&.42435798004
  }
.fi
.SS "const double Aurora::ap2[]"
\fBInitial value:\fP
.PP
.nf
= {
    17\&.007011830208345,
    129\&.17600673030512,
    525\&.775375708461,
    2109\&.1757722295597,
    8464\&.591006904155,
    37626\&.43738022203
  }
.fi
.SS "const char Aurora::DATA_ID[4] = {'d','a','t','a'}"

.SS "const double Aurora::def_base = 16\&."

.SS "const std::size_t Aurora::def_fftsize = 1024"

.SS "const int Aurora::def_ftlen = 16384"

.SS "const std::size_t Aurora::def_hsize = 256"

.SS "const std::size_t Aurora::def_psize = 2048"

.SS "const double Aurora::def_sr = 44100\&."

.SS "const int Aurora::def_vsize = 64"

.SS "const char Aurora::FMT_ID[4] = {'f','m','t',' '}"

.SS "bool Aurora::forward = true\fC [static]\fP"
constant indicating forward \fBFFT\fP direction 
.SS "bool Aurora::inverse = false\fC [static]\fP"
constant indicating inverse \fBFFT\fP direction 
.SS "const bool Aurora::ola = 1"

.SS "const bool Aurora::ols = 0"

.SS "const bool Aurora::packed = true"
constant indicating packed \fBFFT\fP format 
.SS "const char Aurora::RIFF_ID[4] = {'R','I','F','F'}"

.SS "const double Aurora::twopi = 2 * \fBM_PI\fP"

.SS "const char Aurora::WAVE_ID[4] = {'W','A','V','E'}"

.SH "Author"
.PP 
Generated automatically by Doxygen for Aurora from the source code\&.
